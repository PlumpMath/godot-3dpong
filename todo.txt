[x]- ball should get faster every time it hits a paddle. (or better: every time the speed on the Z axis gets negated?)

- make the ball go to the winner's or the loser's side after scoring? research!
	-> the ball always goes to the loser's side (where it went through), with a random angle.
	
	- at the start of the game, the ball will always go to the right player. in a roughly 45 degree angle downwards (maybe a bit less than 45 degrees)
~

- implement win condition. (research how it works in the original pong first!)
	gba pong -> the first player to reach 9 points, wins!
	
	gbc pong:
	- 11 points wins (by itself)
	- 11:12 -> still continues
	- 15:13 -> win
	-> if a player has at least 11 points and the other opponent has at least 2 points less, he wins.
	
	--> we will use the gbc scoring system
~

- build scenes for single player and split-screen. (move everything splitscreen/cam/ui specific from the test scene into a separate scene that will then own an instance of it.)

- how to attach cameras to the viewports later? -> it's probably best if we attach them directly to the viewports and add scripts to them, that move them to follow the objects.


- implement the different InputHandler scripts (see doc/planned_features.txt)

- implement menus. (see doc/planned_features.txt)

- make sound effects and add them. (how does sound work in godot? look at platformer demo)
	- we will need sound effects for the following things:
	
	paddle_hit1 (lower pitched, for paddle 1)
	paddle_hit2 (higher pitched, for paddle 2)
	wall_hit
	block_hit (for breakout mode) (maybe multiple ones, depending on block color?)
~



- implement an imperfect paddle AI


- add 2 switchable physics modes for the ball (after implementing breakout, won't need to do double the scripting work that way):
	- "Realistic Mode": which does proper reflection calculations when the ball hits something (currently implemented as default.)
	
	- "Pong Mode": which ignores proper physics and simply handles all the axis' separately. (i.e.: collision on X axis -> velocity.X gets negated.)
~


- should the reimplementation of all collision code still be done? or will it work fine as-is? (we already move the Paddle via set_translation now. so the wall-collisions aren't a problem anymore.)

???- try reimplementing all collision code... handle paddle-collisions manually (or maybe all collisions?)
	- the Ball will be a RigidBody in Character mode, because we need get_colliding_bodies() and set_linear_velocity() (like in HeartBeast's Breakout tutorial.) (will that cause an acceleration bug, like in the tutorial? the one that happens when you hit the ball with the side of the paddle, when the ball is very slow. it will then accelerate a lot...)
	or use kinematic mode? will get_colliding_bodies() still work, then?
	- Walls will be kept as StaticBodies
	- Paddle will be a KinematicBody, but it will be moved with set_pos() so the paddle will be unstoppable by the ball.
~
???

